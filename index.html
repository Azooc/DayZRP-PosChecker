<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ADM Map Viewer (Leaflet Enoch)</title>

<!-- Leaflet 1.6.0 (same as your working example) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"></script>

<!-- jQuery (used by mapUtils controls) -->
<script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>

<!-- Teammate utilities + Enoch map definition -->
<link rel="stylesheet" href="css/mapUtils.css" />
<script src="js/mapUtils.js"></script>
<script src="maps/enoch.js"></script>

<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9aa4b2}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,#071021 0%,var(--bg) 100%);color:#e6eef6;display:flex;flex-direction:column;align-items:center;padding:20px}
  .wrap{width:min(1200px,95%)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap}
  h1{margin:0;font-size:1.25rem}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type=file]{display:none}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;cursor:pointer;color:inherit}
  .panel{background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-bottom:10px}
  .checkbox{display:inline-flex;gap:8px;align-items:center}

  .viewport{position:relative;height:75vh;min-height:420px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);overflow:hidden;background:#000}
  #map{width:100%;height:100%}

  #playerControls{display:flex;gap:12px;margin:10px 0;align-items:center}
  #playerList{max-height:180px;overflow:auto;font-size:0.9rem;display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
  #playerList label{display:flex;gap:8px;align-items:center}
  .colorInput{width:20px;height:20px;padding:0;border:none;cursor:pointer;}

  #tooltip {
    position:absolute; background:#222; color:#fff; font-size:12px;
    padding:4px 8px; border-radius:4px; pointer-events:none; white-space:pre;
    z-index:3000; display:none;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ADM Map Viewer (Leaflet / Enoch)</h1>
      <div class="controls">
        <label class="btn">üìÅ Upload ADM<input type="file" id="fileInput" accept=".txt,.log,.adm"/></label>
        <button class="btn" id="fitBtn" title="Fit to data">Fit</button>
      </div>
    </header>

    <div class="panel">
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <div>Start: <select id="startTime"></select></div>
        <div>End: <select id="endTime"></select></div>
        <label class="checkbox"><input type="checkbox" id="killToggle"> Kill Logs</label>
        <label class="checkbox"><input type="checkbox" id="damageToggle"> Damage Logs</label>
      </div>
      <div id="playerControls">
        <button class="btn" id="selectAllBtn">Select All</button>
        <button class="btn" id="clearAllBtn">Clear All</button>
      </div>
      <div id="playerList"></div>
    </div>

    <div class="viewport panel">
      <div id="map"></div>
    </div>
  </div>

  <div id="tooltip"></div>

<script>
(() => {
  // ---------- Map boot ----------
  const mapInfos = Arma3Map?.Maps?.enoch;
  if (!mapInfos) {
    alert('maps/enoch.js not loaded or Arma3Map.Maps.enoch missing.');
    return;
  }

  // Allow deeper zoom than native tiles (over-zoom)
  const EXTRA_ZOOM = 4; // adjust if you want more/less over-zoom

  // Gentler zoom without newer APIs:
  // - smaller zoomDelta & zoomSnap make all zoom steps finer
  // (in Leaflet 1.6, wheel speed is fixed, but smaller delta reduces jump size)
  const map = L.map('map', {
    minZoom: mapInfos.minZoom,
    maxZoom: mapInfos.maxZoom + EXTRA_ZOOM,
    crs: mapInfos.CRS,
    zoomDelta: 0.25,
    zoomSnap: 0.25
  });

  // IMPORTANT: Use the exact pattern from enoch.js (this matched your working setup)
  L.tileLayer(mapInfos.tilePattern, {
    attribution: mapInfos.attribution,
    tileSize: mapInfos.tileSize,
    // Over-zoom config: tell Leaflet what the native max is
    // (it will upscale beyond this)
    maxNativeZoom: mapInfos.maxZoom,
    maxZoom: mapInfos.maxZoom + EXTRA_ZOOM
  }).addTo(map);

  map.setView(mapInfos.center, mapInfos.defaultZoom);

  // Helpful overlays from mapUtils.js
  L.latlngGraticule().addTo(map);
  L.control.scale({ maxWidth: 200, imperial: false }).addTo(map);
  L.control.gridMousePosition().addTo(map);

  // ---------- UI refs ----------
  const fileInput=document.getElementById('fileInput');
  const startTimeSel=document.getElementById('startTime');
  const endTimeSel=document.getElementById('endTime');
  const playerListDiv=document.getElementById('playerList');
  const selectAllBtn=document.getElementById('selectAllBtn');
  const clearAllBtn=document.getElementById('clearAllBtn');
  const tooltip=document.getElementById('tooltip');
  const killToggle=document.getElementById('killToggle');
  const damageToggle=document.getElementById('damageToggle');
  const fitBtn=document.getElementById('fitBtn');

  // ---------- State ----------
  const WORLD=12800;
  const timeToSec = t => { const [H,M,S]=t.split(':').map(n=>+n); return (H*3600+M*60+S)|0; };
  const worldToLatLng = p => L.latLng(p.z, p.x); // lat=z, lng=x

  let snapshots=new Map(),orderedTimestamps=[];
  let killEvents=[];       // PvP kills
  let aiDeaths=[];         // AI kills
  let suicides=[];         // suicides
  let dmgPvpEvents=[];     // PvP damage
  let dmgAiEvents=[];      // AI/animal damage

  let selectedPlayers=new Set();
  let playerColors=new Map();

  // Layers
  const tracksLayer      = L.layerGroup().addTo(map);
  const dotsLayer        = L.layerGroup().addTo(map);
  const killsLayer       = L.layerGroup().addTo(map);
  const damageLayer      = L.layerGroup().addTo(map);
  const highlightsLayer  = L.layerGroup().addTo(map);

  function clearAllLayers(){
    tracksLayer.clearLayers();
    dotsLayer.clearLayers();
    killsLayer.clearLayers();
    damageLayer.clearLayers();
    highlightsLayer.clearLayers();
  }

  // ---------- Tooltip helpers ----------
  function showTooltip(x,y,text){ tooltip.style.display='block'; tooltip.textContent=text; moveTooltip(x,y); }
  function moveTooltip(x,y){ tooltip.style.left=(x+12)+'px'; tooltip.style.top=(y+12)+'px'; }
  function hideTooltip(){ tooltip.style.display='none'; }

  // ---------- Colors ----------
  function darkerColor(hex){
    const c=document.createElement("canvas").getContext("2d");
    c.fillStyle=hex;c.fillRect(0,0,1,1);
    const [r,g,b]=c.getImageData(0,0,1,1).data;
    return `rgb(${r*0.6},${g*0.6},${b*0.6})`;
  }

  // ---------- Regex ----------
  const posRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<name>.+?)"\s*\(id=(?<id>\d+)\s+pos=<\s*(?<x>[-+\d.]+)\s*,\s*(?<z>[-+\d.]+)\s*,\s*(?<y>[-+\d.]+)\s*>\)\s*$/i;

  const killRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(DEAD\)\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*killed by\s*Player\s+"(?<killer>.+?)"\s*\(id=(?<kid>\d+)\s+pos=<\s*(?<kx>[-+\d.]+)\s*,\s*(?<kz>[-+\d.]+)\s*,\s*(?<ky>[-+\d.]+)\s*>\)\s*with\s*(?<weapon>.+?)\s*from\s*(?<dist>[-+\d.]+)\s*meters\s*$/i;

  const aiRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(DEAD\)\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*killed by\s*(?!Player\b)(?<ai>.+?)\s*$/i;

  const suicideRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*committed suicide\s*$/i;

  const dmgPvpRe =
  /^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*(?:\(DEAD\)\s*)?\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*(?:\[\s*HP:\s*(?<hp>[-+\d.]+)\s*\]\s*)?hit by\s*Player\s+"(?<attacker>.+?)"\s*\(id=(?<aid>\d+)\s+pos=<\s*(?<ax>[-+\d.]+)\s*,\s*(?<az>[-+\d.]+)\s*,\s*(?<ay>[-+\d.]+)\s*>\)\s*into\s*(?<part>[A-Za-z]+)\(\d+\)\s*for\s*(?<dmg>[-+\d.]+)\s*damage\s*\((?<attack>[^)]+)\)\s*with\s*(?<weapon>.+?)(?:\s*from\s*(?<dist>[-+\d.]+)\s*meters)?\s*$/i;

  const dmgAiRe =
  /^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*(?:\[\s*HP:\s*(?<hp>[-+\d.]+)\s*\]\s*)?hit by\s*(?<ai>.+?)\s*into\s*(?<part>[A-Za-z]+)\(\d+\)\s*for\s*(?<dmg>[-+\d.]+)\s*damage\s*\((?<attack>[^)]+)\)(?:\s*from\s*(?<dist>[-+\d.]+)\s*meters)?\s*$/i;

  // ---------- Parsing ----------
  function parseADM(text){
    snapshots.clear(); orderedTimestamps=[]; killEvents=[]; aiDeaths=[]; suicides=[]; dmgPvpEvents=[]; dmgAiEvents=[];
    for(const raw of text.split(/\r?\n/)){
      let m=raw.match(posRe);
      if(m){
        const {time,name,id,x,z,y}=m.groups;
        if(!snapshots.has(time)){snapshots.set(time,[]);orderedTimestamps.push(time);}
        snapshots.get(time).push({name,id,x:+x,z:+z,y:+y});
        continue;
      }
      m=raw.match(killRe);
      if(m){
        const g=m.groups;
        killEvents.push({
          time:g.time,
          victimName:g.victim, killerName:g.killer,
          weapon:g.weapon.trim(), distance:+g.dist,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy},
          killer:{x:+g.kx,z:+g.kz,y:+g.ky}
        });
        continue;
      }
      m=raw.match(aiRe);
      if(m){
        const g=m.groups;
        aiDeaths.push({
          time:g.time,
          victimName:g.victim,
          ai:g.ai.trim(),
          victim:{x:+g.vx,z:+g.vz,y:+g.vy}
        });
        continue;
      }
      m=raw.match(suicideRe);
      if(m){
        const g=m.groups;
        suicides.push({
          time:g.time,
          victimName:g.victim,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy}
        });
        continue;
      }
      m=raw.match(dmgPvpRe);
      if(m){
        const g=m.groups;
        dmgPvpEvents.push({
          time:g.time,
          victimName:g.victim,
          attackerName:g.attacker,
          hp:(g.hp!==undefined && g.hp!==null)? +g.hp : null,
          part:g.part, damage:+g.dmg,
          attack:g.attack.trim(), weapon:g.weapon.trim(),
          distance:(g.dist!==undefined && g.dist!==null)? +g.dist : null,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy},
          attacker:{x:+g.ax,z:+g.az,y:+g.ay}
        });
        continue;
      }
      m=raw.match(dmgAiRe);
      if(m){
        const g=m.groups;
        dmgAiEvents.push({
          time:g.time,
          victimName:g.victim,
          hp:(g.hp!==undefined && g.hp!==null)? +g.hp : null,
          part:g.part, damage:+g.dmg,
          attack:g.attack.trim(), ai:g.ai.trim(),
          distance:(g.dist!==undefined && g.dist!==null)? +g.dist : null,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy}
        });
        continue;
      }
    }
  }

  function populateTimestamps(){
    startTimeSel.innerHTML=''; endTimeSel.innerHTML='';
    for(const t of orderedTimestamps){
      const a=document.createElement('option'); a.value=t; a.textContent=t; startTimeSel.appendChild(a);
      const b=document.createElement('option'); b.value=t; b.textContent=t; endTimeSel.appendChild(b);
    }
    if(orderedTimestamps.length){
      startTimeSel.value=orderedTimestamps[0];
      endTimeSel.value=orderedTimestamps[0];
    }
  }

  function gatherPlayersInRange(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    const mapP=new Map();
    orderedTimestamps.forEach(t=>{
      const ts=timeToSec(t);
      if(ts>=lo && ts<=hi){
        for(const p of (snapshots.get(t)||[])){
          if(!mapP.has(p.name)) mapP.set(p.name,[]);
          mapP.get(p.name).push({...p,time:t});
        }
      }
    });
    return mapP;
  }

  function killsInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return killEvents.filter(k=>{
      const ts=timeToSec(k.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(k.victimName) || selectedPlayers.has(k.killerName);
    });
  }

  function aiInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return aiDeaths.filter(k=>{
      const ts=timeToSec(k.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(k.victimName);
    });
  }

  function suicidesInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return suicides.filter(s=>{
      const ts=timeToSec(s.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(s.victimName);
    });
  }

  function damagePvpInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return dmgPvpEvents.filter(ev=>{
      const ts=timeToSec(ev.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(ev.victimName) || selectedPlayers.has(ev.attackerName);
    });
  }

  function damageAiInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return dmgAiEvents.filter(ev=>{
      const ts=timeToSec(ev.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(ev.victimName);
    });
  }

  function ensureDefaults(names){
    for(const n of names){
      if(!playerColors.has(n)) playerColors.set(n,'#ff0000');
      selectedPlayers.add(n);
    }
  }

  function populatePlayerListForRange(){
    const paths=gatherPlayersInRange();
    const names=[...paths.keys()].sort((a,b)=>a.localeCompare(b));
    ensureDefaults(names);
    playerListDiv.innerHTML='';
    for(const n of names){
      const color=playerColors.get(n)||'#ff0000';
      const label=document.createElement('label');

      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=selectedPlayers.has(n);
      cb.addEventListener('change',()=>{ cb.checked?selectedPlayers.add(n):selectedPlayers.delete(n); renderRange(); });

      const colorInput=document.createElement('input');
      colorInput.type='color'; colorInput.value=color; colorInput.className='colorInput';
      colorInput.addEventListener('input',()=>{ playerColors.set(n,colorInput.value); renderRange(); });

      label.appendChild(cb); label.appendChild(colorInput); label.appendChild(document.createTextNode(' '+n));
      playerListDiv.appendChild(label);
    }
  }

  // ---------- Zoom-scaled styling + arrows ----------
  function strokeForZoom() {
    const z = map.getZoom();
    // slim lines, scale gently
    return Math.max(1.25, 0.8 + 0.35 * (z - mapInfos.minZoom));
  }

  function arrowSizeForZoom() {
    const z = map.getZoom();
    // world units
    return 28 + 5 * (z - mapInfos.minZoom);
  }

  function addArrowhead(p0, p1, color) {
    const dx = p1.x - p0.x;
    const dy = p1.z - p0.z;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;

    const Lw = arrowSizeForZoom();
    const Bw = Lw * 0.55;
    const bx = p1.x - ux * Lw;
    const by = p1.z - uy * Lw;
    const px = -uy, py = ux;

    const left  = { x: bx + px * Bw, z: by + py * Bw };
    const right = { x: bx - px * Bw, z: by - py * Bw };

    return L.polygon([
      worldToLatLng(left),
      worldToLatLng(p1),
      worldToLatLng(right)
    ], { color: '#fff', weight: 2, fillColor: color, fillOpacity: 1 });
  }

  // ---------- Leaflet drawing helpers ----------
  function addDot(pos, color, tooltipText, radius){
    const latlng = worldToLatLng(pos);
    const r = radius ?? 6;
    const m = L.circleMarker(latlng, {
      radius: r, color: '#fff', weight: 2, fillColor: color, fillOpacity: 1
    }).addTo(dotsLayer);
    m.on('mouseover', e => showTooltip(e.originalEvent.pageX, e.originalEvent.pageY, tooltipText));
    m.on('mousemove', e => moveTooltip(e.originalEvent.pageX, e.originalEvent.pageY));
    m.on('mouseout',  hideTooltip);
  }

  function addTrack(p0, p1, color){
    const w = strokeForZoom();
    // segment
    L.polyline([worldToLatLng(p0), worldToLatLng(p1)], {
      color: darkerColor(color), weight: w, opacity: 0.9
    }).addTo(tracksLayer);
    // arrowhead at end
    addArrowhead(p0, p1, color).addTo(tracksLayer);
  }

  function addKillX(center, color, weight){
    const arm = 40;
    const c = worldToLatLng(center);
    const w = (weight ?? 5);

    const a1w = L.polyline([
      L.latLng(c.lat - arm, c.lng - arm), L.latLng(c.lat + arm, c.lng + arm)
    ], { color:'#fff', weight:w*1.6 }).addTo(killsLayer);
    const a1  = L.polyline([
      L.latLng(c.lat - arm, c.lng - arm), L.latLng(c.lat + arm, c.lng + arm)
    ], { color,       weight:w }).addTo(killsLayer);

    const a2w = L.polyline([
      L.latLng(c.lat + arm, c.lng - arm), L.latLng(c.lat - arm, c.lng + arm)
    ], { color:'#fff', weight:w*1.6 }).addTo(killsLayer);
    const a2  = L.polyline([
      L.latLng(c.lat + arm, c.lng - arm), L.latLng(c.lat - arm, c.lng + arm)
    ], { color,       weight:w }).addTo(killsLayer);

    return L.layerGroup([a1w,a1,a2w,a2]);
  }

  function addBurst(center, color, weight){
    const c = worldToLatLng(center);
    const rOuter = 50, rInner = rOuter*0.45, spikes=8;
    const pts=[]; for(let i=0;i<spikes*2;i++){
      const ang=(Math.PI/spikes)*i, rr=(i%2===0)?rOuter:rInner;
      const dx=Math.cos(ang)*rr, dy=Math.sin(ang)*rr;
      pts.push(L.latLng(c.lat + dy, c.lng + dx));
    }
    const outline=L.polygon(pts,{color:'#000',weight:(weight??5)*1.6,fillColor:'#000',fillOpacity:1});
    const body   =L.polygon(pts,{color:'#fff',weight:(weight??5)*1.1,fillColor:color, fillOpacity:1});
    const group=L.layerGroup([outline,body]).addTo(damageLayer);
    return group;
  }

  function addDiamond(center, color, size, name){
    const c=worldToLatLng(center), r=size??40;
    const pts=[ L.latLng(c.lat - r, c.lng),
                L.latLng(c.lat, c.lng + r),
                L.latLng(c.lat + r, c.lng),
                L.latLng(c.lat, c.lng - r) ];
    const poly=L.polygon(pts,{color:'#fff',weight:4,fillColor:color,fillOpacity:1}).addTo(highlightsLayer);
    const label=`${name} (Victim)\nX:${center.x.toFixed(1)} Z:${center.z.toFixed(1)} Y:${center.y.toFixed(1)}`;
    poly.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,label));
    poly.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
    poly.on('mouseout', hideTooltip);
  }
  function addTriangle(center, color, size, name){
    const c=worldToLatLng(center), a=size??40, h=a*Math.sqrt(3);
    const top=L.latLng(c.lat - a, c.lng);
    const br =L.latLng(c.lat + a*0.9, c.lng + (h/2)*0.577);
    const bl =L.latLng(c.lat + a*0.9, c.lng - (h/2)*0.577);
    const poly=L.polygon([top,br,bl],{color:'#fff',weight:4,fillColor:color,fillOpacity:1}).addTo(highlightsLayer);
    const label=`${name} (Attacker)\nX:${center.x.toFixed(1)} Z:${center.z.toFixed(1)} Y:${center.y.toFixed(1)}`;
    poly.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,label));
    poly.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
    poly.on('mouseout', hideTooltip);
  }

  // ---------- Render ----------
  function renderRange(){
    clearAllLayers(); hideTooltip();

    const paths=gatherPlayersInRange();

    // Tracks & dots
    paths.forEach((positions,name)=>{
      if(!selectedPlayers.has(name))return;
      const color=playerColors.get(name)||'#ff0000';
      positions.sort((a,b)=>timeToSec(a.time)-timeToSec(b.time));

      if(positions.length>1){
        for(let i=1;i<positions.length;i++){
          addTrack(positions[i-1], positions[i], color);
        }
      }

      for(const pos of positions){
        addDot(pos, color, `${name}\n${pos.time}\nX:${pos.x.toFixed(1)} Z:${pos.z.toFixed(1)} Y:${pos.y.toFixed(1)}`, 6);
      }
    });

    // Kills
    if(killToggle.checked){
      for(const k of killsInRangeFiltered()){
        const color=playerColors.get(k.victimName)||'#ff0000';
        const g=addKillX(k.victim, color, 5);
        g.addTo(killsLayer);
        const tip=`${k.victimName} killed by ${k.killerName}\nwith ${k.weapon} from ${k.distance.toFixed(2)} m\n${k.time}`;
        g.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,tip));
        g.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
        g.on('mouseout', hideTooltip);
        g.on('click', ()=>{
          highlightsLayer.clearLayers();
          addDiamond(k.victim,  playerColors.get(k.victimName)||'#ff0000', 40, k.victimName);
          addTriangle(k.killer, playerColors.get(k.killerName)||'#ff0000', 40, k.killerName);
        });
      }
      for(const k of aiInRangeFiltered()){
        const color=playerColors.get(k.victimName)||'#ff0000';
        const g=addKillX(k.victim, color, 5).addTo(killsLayer);
        g.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,`${k.victimName} killed by AI ${k.ai}\n${k.time}`));
        g.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
        g.on('mouseout', hideTooltip);
      }
      for(const s of suicidesInRangeFiltered()){
        const color=playerColors.get(s.victimName)||'#ff0000';
        const g=addKillX(s.victim, color, 5).addTo(killsLayer);
        g.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,`${s.victimName} committed suicide\n${s.time}`));
        g.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
        g.on('mouseout', hideTooltip);
      }
    }

    // Damage
    if(damageToggle.checked){
      for(const ev of damagePvpInRangeFiltered()){
        const color=playerColors.get(ev.victimName)||'#ff0000';
        const hpText   = (ev.hp??ev.hp===0) ? `\nHP: ${ev.hp.toFixed(2)}` : '';
        const distText = (ev.distance??ev.distance===0) ? `\nDist: ${ev.distance.toFixed(2)} m` : '';
        const tip = `${ev.victimName} hit by ${ev.attackerName}\n${ev.part} for ${ev.damage} dmg\n${ev.attack} with ${ev.weapon}${distText}${hpText}\n${ev.time}`;
        const g=addBurst(ev.victim, color, 5);
        g.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,tip));
        g.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
        g.on('mouseout', hideTooltip);
        g.on('click', ()=>{
          highlightsLayer.clearLayers();
          addDiamond(ev.victim,  playerColors.get(ev.victimName)||'#ff0000', 40, ev.victimName);
          addTriangle(ev.attacker, playerColors.get(ev.attackerName)||'#ff0000', 40, ev.attackerName);
        });
      }
      for(const ev of damageAiInRangeFiltered()){
        const color=playerColors.get(ev.victimName)||'#ff0000';
        const hpText   = (ev.hp??ev.hp===0) ? `\nHP: ${ev.hp.toFixed(2)}` : '';
        const distText = (ev.distance??ev.distance===0) ? `\nDist: ${ev.distance.toFixed(2)} m` : '';
        const tip = `${ev.victimName} hit by ${ev.ai}\n${ev.part} for ${ev.damage} dmg\n${ev.attack}${distText}${hpText}\n${ev.time}`;
        const g=addBurst(ev.victim, color, 5);
        g.on('mouseover', e=>showTooltip(e.originalEvent.pageX,e.originalEvent.pageY,tip));
        g.on('mousemove', e=>moveTooltip(e.originalEvent.pageX,e.originalEvent.pageY));
        g.on('mouseout', hideTooltip);
      }
    }
  }

  // ---------- Fit to data ----------
  function fitToData(){
    const latlngs=[];
    const paths=gatherPlayersInRange();
    for(const [name,positions] of paths){
      for(const p of positions) latlngs.push(worldToLatLng(p));
    }
    if(latlngs.length){
      const bounds=L.latLngBounds(latlngs);
      map.fitBounds(bounds.pad(0.10));
    }
  }

  // ---------- Re-render on interactions ----------
  map.on('zoomend', renderRange); // keep line thickness/arrow size in sync with zoom

  // ---------- UI wiring ----------
  startTimeSel.addEventListener('change',()=>{populatePlayerListForRange();renderRange();});
  endTimeSel.addEventListener('change',()=>{populatePlayerListForRange();renderRange();});
  killToggle.addEventListener('change',()=>{renderRange();});
  damageToggle.addEventListener('change',()=>{renderRange();});
  fitBtn.addEventListener('click', fitToData);

  selectAllBtn.addEventListener('click',()=>{
    const paths=gatherPlayersInRange(); selectedPlayers=new Set(paths.keys());
    playerListDiv.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true);
    [...paths.keys()].forEach(n=>playerColors.set(n,'#ff0000'));
    renderRange();
  });
  clearAllBtn.addEventListener('click',()=>{
    selectedPlayers.clear();
    playerListDiv.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=false);
    renderRange();
  });

  fileInput.addEventListener('change',e=>{
    const f=e.target.files?.[0]; if(!f)return;
    const reader=new FileReader();
    reader.onload=()=>{parseADM(String(reader.result||'')); populateTimestamps(); populatePlayerListForRange(); renderRange(); fitToData();};
    reader.readAsText(f);
  });

})();
</script>
</body>
</html>
