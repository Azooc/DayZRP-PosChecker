<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ADM Map Viewer</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9aa4b2;--accent:#7dd3fc}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,#071021 0%,var(--bg) 100%);color:#e6eef6;display:flex;flex-direction:column;align-items:center;padding:20px}
  .wrap{width:min(1200px,95%)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap}
  h1{margin:0;font-size:1.25rem}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type=file]{display:none}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;cursor:pointer;color:inherit}

  .panel{background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-bottom:10px}

  .viewport{position:relative;height:75vh;min-height:420px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);overflow:hidden;background:#000;user-select:none;touch-action:none}
  .stage{position:absolute;left:0;top:0;transform-origin:0 0}
  .stage img{display:block}
  .overlay{position:absolute;left:0;top:0;width:100%;height:100%}

  #playerControls{display:flex;gap:12px;margin:10px 0;align-items:center}
  #playerList{max-height:180px;overflow:auto;font-size:0.9rem;display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
  #playerList label{display:flex;gap:8px;align-items:center}
  .colorInput{width:20px;height:20px;padding:0;border:none;cursor:pointer;}

  .track{opacity:0.9;stroke-linecap:round}
  .poi{transition:all 0.15s ease;}
  .poi.hovered{filter:brightness(1.4);}

  #tooltip {
    position:absolute;
    background:#222;
    color:#fff;
    font-size:12px;
    padding:4px 8px;
    border-radius:4px;
    pointer-events:none;
    white-space:pre;
    z-index:3000;
    display:none;
  }
  .checkbox{display:inline-flex;gap:8px;align-items:center}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ADM Map Viewer</h1>
      <div class="controls">
        <label class="btn">üìÅ Upload ADM<input type="file" id="fileInput" accept=".txt,.log,.adm"/></label>
        <button class="btn" id="fitBtn" title="Fit to screen">Fit</button>
      </div>
    </header>

    <div class="panel">
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <div>Start: <select id="startTime"></select></div>
        <div>End: <select id="endTime"></select></div>
        <label class="checkbox"><input type="checkbox" id="killToggle"> Kill Logs</label>
      </div>
      <div id="playerControls">
        <button class="btn" id="selectAllBtn">Select All</button>
        <button class="btn" id="clearAllBtn">Clear All</button>
      </div>
      <div id="playerList"></div>
    </div>

    <div class="viewport panel" id="viewport">
      <div class="stage" id="stage">
        <img id="map" src="map.jpg" alt="Map"/>
        <svg id="overlay" class="overlay" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
              <path d="M0,0 L6,3 L0,6 Z" fill="context-stroke"></path>
            </marker>
          </defs>
          <g id="tracks"></g>
          <g id="dots"></g>
          <g id="kills"></g>
          <g id="highlights"></g>
        </svg>
      </div>
    </div>
  </div>

  <div id="tooltip"></div>

<script>
(() => {
  const WORLD=12800;

  const fileInput=document.getElementById('fileInput');
  const viewport=document.getElementById('viewport');
  const stage=document.getElementById('stage');
  const mapImg=document.getElementById('map');
  const overlay=document.getElementById('overlay');
  const gTracks=document.getElementById('tracks');
  const gDots=document.getElementById('dots');
  const gKills=document.getElementById('kills');
  const gHighlights=document.getElementById('highlights');
  const fitBtn=document.getElementById('fitBtn');
  const startTimeSel=document.getElementById('startTime');
  const endTimeSel=document.getElementById('endTime');
  const playerListDiv=document.getElementById('playerList');
  const selectAllBtn=document.getElementById('selectAllBtn');
  const clearAllBtn=document.getElementById('clearAllBtn');
  const tooltip=document.getElementById('tooltip');
  const killToggle=document.getElementById('killToggle');

  let snapshots=new Map(),orderedTimestamps=[];
  let killEvents=[];       // PvP
  let aiDeaths=[];         // AI kills
  let suicides=[];         // suicides
  let imgW=0,imgH=0;
  let scale=1,tx=0,ty=0,fitScale=1;
  let MIN_SCALE=0.001,MAX_SCALE=200;
  let selectedPlayers=new Set();
  let playerColors=new Map();

  // Tuned sizes
  const baseDotSize=25, baseStroke=5, baseLine=10;
  const dotMin=0.02, dotMax=25, lineMin=0.04, lineMax=1.5;

  // Regexes
  const posRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<name>.+?)"\s*\(id=(?<id>\d+)\s+pos=<\s*(?<x>[-+\d.]+)\s*,\s*(?<z>[-+\d.]+)\s*,\s*(?<y>[-+\d.]+)\s*>\)\s*$/i;

  const killRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(DEAD\)\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*killed by\s*Player\s+"(?<killer>.+?)"\s*\(id=(?<kid>\d+)\s+pos=<\s*(?<kx>[-+\d.]+)\s*,\s*(?<kz>[-+\d.]+)\s*,\s*(?<ky>[-+\d.]+)\s*>\)\s*with\s*(?<weapon>.+?)\s*from\s*(?<dist>[-+\d.]+)\s*meters\s*$/i;

  // AI kills (anything after "killed by" that is NOT "Player ...")
  const aiRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(DEAD\)\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*killed by\s*(?!Player\b)(?<ai>.+?)\s*$/i;

  // Suicide
  const suicideRe=/^(?<time>\d{2}:\d{2}:\d{2})\s*\|\s*Player\s+"(?<victim>.+?)"\s*\(id=(?<vid>\d+)\s+pos=<\s*(?<vx>[-+\d.]+)\s*,\s*(?<vz>[-+\d.]+)\s*,\s*(?<vy>[-+\d.]+)\s*>\)\s*committed suicide\s*$/i;

  const timeToSec = t => { const [H,M,S]=t.split(':').map(n=>+n); return (H*3600+M*60+S)|0; };
  const worldToImagePx = p => ({ xpx:(p.x/WORLD)*imgW, ypx:imgH-(p.z/WORLD)*imgH });

  function darkerColor(hex){
    const c=document.createElement("canvas").getContext("2d");
    c.fillStyle=hex;c.fillRect(0,0,1,1);
    const [r,g,b]=c.getImageData(0,0,1,1).data;
    return `rgb(${r*0.6},${g*0.6},${b*0.6})`;
  }

  function parseADM(text){
    snapshots.clear(); orderedTimestamps=[]; killEvents=[]; aiDeaths=[]; suicides=[];
    for(const raw of text.split(/\r?\n/)){
      let m=raw.match(posRe);
      if(m){
        const {time,name,id,x,z,y}=m.groups;
        if(!snapshots.has(time)){snapshots.set(time,[]);orderedTimestamps.push(time);}
        snapshots.get(time).push({name,id,x:+x,z:+z,y:+y});
        continue;
      }
      m=raw.match(killRe);
      if(m){
        const g=m.groups;
        killEvents.push({
          time:g.time,
          victimName:g.victim, killerName:g.killer,
          weapon:g.weapon.trim(), distance:+g.dist,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy},
          killer:{x:+g.kx,z:+g.kz,y:+g.ky}
        });
        continue;
      }
      m=raw.match(aiRe);
      if(m){
        const g=m.groups;
        aiDeaths.push({
          time:g.time,
          victimName:g.victim,
          ai:g.ai.trim(),
          victim:{x:+g.vx,z:+g.vz,y:+g.vy}
        });
        continue;
      }
      m=raw.match(suicideRe);
      if(m){
        const g=m.groups;
        suicides.push({
          time:g.time,
          victimName:g.victim,
          victim:{x:+g.vx,z:+g.vz,y:+g.vy}
        });
        continue;
      }
    }
  }

  function populateTimestamps(){
    startTimeSel.innerHTML=''; endTimeSel.innerHTML='';
    for(const t of orderedTimestamps){
      const a=document.createElement('option'); a.value=t; a.textContent=t; startTimeSel.appendChild(a);
      const b=document.createElement('option'); b.value=t; b.textContent=t; endTimeSel.appendChild(b);
    }
    if(orderedTimestamps.length){
      startTimeSel.value=orderedTimestamps[0];
      endTimeSel.value=orderedTimestamps[0];
    }
  }

  function gatherPlayersInRange(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    const map=new Map();
    orderedTimestamps.forEach(t=>{
      const ts=timeToSec(t);
      if(ts>=lo && ts<=hi){
        for(const p of (snapshots.get(t)||[])){
          if(!map.has(p.name)) map.set(p.name,[]);
          map.get(p.name).push({...p,time:t});
        }
      }
    });
    return map;
  }

  function killsInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    // PvP only if victim or attacker is selected
    return killEvents.filter(k=>{
      const ts=timeToSec(k.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(k.victimName) || selectedPlayers.has(k.killerName);
    });
  }

  function aiInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return aiDeaths.filter(k=>{
      const ts=timeToSec(k.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(k.victimName);
    });
  }

  function suicidesInRangeFiltered(){
    const a=timeToSec(startTimeSel.value||'00:00:00');
    const b=timeToSec(endTimeSel.value||'00:00:00');
    const lo=Math.min(a,b), hi=Math.max(a,b);
    return suicides.filter(s=>{
      const ts=timeToSec(s.time);
      if(!(ts>=lo && ts<=hi)) return false;
      return selectedPlayers.has(s.victimName);
    });
  }

  function ensureDefaults(names){
    for(const n of names){
      if(!playerColors.has(n)) playerColors.set(n,'#ff0000');
      selectedPlayers.add(n);
    }
  }

  function populatePlayerListForRange(){
    const paths=gatherPlayersInRange();
    const names=[...paths.keys()].sort((a,b)=>a.localeCompare(b));
    ensureDefaults(names);
    playerListDiv.innerHTML='';
    for(const n of names){
      const color=playerColors.get(n)||'#ff0000';
      const label=document.createElement('label');

      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=selectedPlayers.has(n);
      cb.addEventListener('change',()=>{ cb.checked?selectedPlayers.add(n):selectedPlayers.delete(n); renderRange(); });

      const colorInput=document.createElement('input');
      colorInput.type='color'; colorInput.value=color; colorInput.className='colorInput';
      colorInput.addEventListener('input',()=>{ playerColors.set(n,colorInput.value); renderRange(); });

      label.appendChild(cb); label.appendChild(colorInput); label.appendChild(document.createTextNode(' '+n));
      playerListDiv.appendChild(label);
    }
  }

  function renderRange(){
    gTracks.innerHTML=''; gDots.innerHTML=''; gKills.innerHTML=''; gHighlights.innerHTML='';
    tooltip.style.display='none';

    const paths=gatherPlayersInRange();

    const raw=fitScale/scale;
    const dotFactor=Math.min(dotMax,Math.max(dotMin,raw));
    const lineFactor=Math.min(lineMax,Math.max(lineMin,raw));
    const dotSize=baseDotSize*dotFactor;
    const strokeW=baseStroke*dotFactor;
    const lineW=baseLine*lineFactor;

    // Tracks & dots
    paths.forEach((positions,name)=>{
      if(!selectedPlayers.has(name))return;
      const color=playerColors.get(name)||'#ff0000';
      const lineColor=darkerColor(color);
      positions.sort((a,b)=>timeToSec(a.time)-timeToSec(b.time));

      if(positions.length>1){
        for(let i=1;i<positions.length;i++){
          const p0=worldToImagePx(positions[i-1]);
          const p1=worldToImagePx(positions[i]);
          const dx=p1.xpx-p0.xpx,dy=p1.ypx-p0.ypx,len=Math.hypot(dx,dy)||1;
          const offset=dotSize+2;const ox=(dx/len)*offset,oy=(dy/len)*offset;
          const line=document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1',p0.xpx+ox); line.setAttribute('y1',p0.ypx+oy);
          line.setAttribute('x2',p1.xpx-ox); line.setAttribute('y2',p1.ypx-oy);
          line.setAttribute('stroke-width',lineW);
          line.setAttribute('class','track'); line.setAttribute('stroke',lineColor);
          line.setAttribute('marker-end','url(#arrowhead)');
          gTracks.appendChild(line);
        }
      }

      for(const pos of positions){
        const {xpx,ypx}=worldToImagePx(pos);
        const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',xpx); c.setAttribute('cy',ypx);
        c.setAttribute('r',dotSize);
        c.setAttribute('stroke-width',strokeW);
        c.setAttribute('class','poi'); c.setAttribute('fill',color);
        c.setAttribute('stroke','#fff');

        c.addEventListener('mouseenter',()=>{
          c.classList.add('hovered');
          tooltip.style.display='block';
          tooltip.textContent=`${name}\n${pos.time}\nX:${pos.x.toFixed(1)} Z:${pos.z.toFixed(1)} Y:${pos.y.toFixed(1)}`;
        });
        c.addEventListener('mousemove',(e)=>{ tooltip.style.left=(e.pageX+12)+'px'; tooltip.style.top=(e.pageY+12)+'px'; });
        c.addEventListener('mouseleave',()=>{ c.classList.remove('hovered'); tooltip.style.display='none'; });

        gDots.appendChild(c);
      }
    });

    if(killToggle.checked){
      // PvP kills (clickable => role markers)
      for(const k of killsInRangeFiltered()){
        const vicPx=worldToImagePx(k.victim);
        const color=playerColors.get(k.victimName)||'#ff0000';
        drawKillX(vicPx.xpx, vicPx.ypx, dotSize, strokeW, color, '#fff',
          `${k.victimName} killed by ${k.killerName}\nwith ${k.weapon} from ${k.distance.toFixed(2)} meters`,
          () => {
            gHighlights.innerHTML='';
            drawRoleMarker('victim', vicPx.xpx, vicPx.ypx, dotSize, playerColors.get(k.victimName)||'#ff0000', `${k.victimName} (Victim)`, strokeW);
            const killerPx=worldToImagePx(k.killer);
            drawRoleMarker('attacker', killerPx.xpx, killerPx.ypx, dotSize, playerColors.get(k.killerName)||'#ff0000', `${k.killerName} (Attacker)`, strokeW);
          }
        );
      }

      // AI kills (non-clickable)
      for(const k of aiInRangeFiltered()){
        const vicPx=worldToImagePx(k.victim);
        const color=playerColors.get(k.victimName)||'#ff0000';
        drawKillX(vicPx.xpx, vicPx.ypx, dotSize, strokeW, color, '#fff',
          `${k.victimName} killed by AI ${k.ai}`, null
        );
      }

      // Suicides (non-clickable)
      for(const s of suicidesInRangeFiltered()){
        const px=worldToImagePx(s.victim);
        const color=playerColors.get(s.victimName)||'#ff0000';
        drawKillX(px.xpx, px.ypx, dotSize, strokeW, color, '#fff',
          `${s.victimName} committed suicide`, null
        );
      }
    }

    applyTransform();
  }

  // Draw an "X" marker at (cx,cy)
function drawKillX(cx, cy, r, strokeW, color, outline, hoverText, onClick){
  const arm = r * 1.8; // bigger X
  const x1 = cx - arm, y1 = cy - arm, x2 = cx + arm, y2 = cy + arm;
  const x3 = cx - arm, y3 = cy + arm, x4 = cx + arm, y4 = cy - arm;

  const l1 = document.createElementNS('http://www.w3.org/2000/svg','line');
  l1.setAttribute('x1',x1); l1.setAttribute('y1',y1);
  l1.setAttribute('x2',x2); l1.setAttribute('y2',y2);
  l1.setAttribute('stroke',color);
  l1.setAttribute('stroke-width',strokeW * 1.5); // bolder
  l1.setAttribute('stroke-linecap','round');

  const l2 = document.createElementNS('http://www.w3.org/2000/svg','line');
  l2.setAttribute('x1',x3); l2.setAttribute('y1',y3);
  l2.setAttribute('x2',x4); l2.setAttribute('y2',y4);
  l2.setAttribute('stroke',color);
  l2.setAttribute('stroke-width',strokeW * 1.5);
  l2.setAttribute('stroke-linecap','round');

  const ol1 = l1.cloneNode(true);
  ol1.setAttribute('stroke', outline);
  ol1.setAttribute('stroke-width', strokeW * 2.5); // thicker outline

  const ol2 = l2.cloneNode(true);
  ol2.setAttribute('stroke', outline);
  ol2.setAttribute('stroke-width', strokeW * 2.5);

  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.appendChild(ol1); g.appendChild(ol2);
  g.appendChild(l1); g.appendChild(l2);

  g.addEventListener('mouseenter',()=>{ tooltip.style.display='block'; tooltip.textContent=hoverText; });
  g.addEventListener('mousemove',(e)=>{ tooltip.style.left=(e.pageX+12)+'px'; tooltip.style.top=(e.pageY+12)+'px'; });
  g.addEventListener('mouseleave',()=>{ tooltip.style.display='none'; });
  if(onClick){ g.addEventListener('click', onClick); }

  gKills.appendChild(g);
}

  // Role marker at (cx,cy): diamond (victim) or triangle (attacker)
  function drawRoleMarker(role, cx, cy, r, color, label, strokeW){
    const grp=document.createElementNS('http://www.w3.org/2000/svg','g');

    if(role==='victim'){
      const pts = [
        [cx, cy - r],
        [cx + r, cy],
        [cx, cy + r],
        [cx - r, cy]
      ].map(p=>p.join(',')).join(' ');
      const poly=document.createElementNS('http://www.w3.org/2000/svg','polygon');
      poly.setAttribute('points', pts);
      poly.setAttribute('fill', color);
      poly.setAttribute('stroke', '#fff');
      poly.setAttribute('stroke-width', strokeW);
      grp.appendChild(poly);
    } else {
      const a = r;
      const h = a * Math.sqrt(3);
      const pTop = [cx, cy - a];
      const pBR  = [cx + (h/2)*0.577, cy + a*0.9];
      const pBL  = [cx - (h/2)*0.577, cy + a*0.9];
      const pts = [pTop,pBR,pBL].map(p=>p.join(',')).join(' ');
      const tri=document.createElementNS('http://www.w3.org/2000/svg','polygon');
      tri.setAttribute('points', pts);
      tri.setAttribute('fill', color);
      tri.setAttribute('stroke', '#fff');
      tri.setAttribute('stroke-width', strokeW);
      grp.appendChild(tri);
    }

    grp.addEventListener('mouseenter',()=>{ tooltip.style.display='block'; tooltip.textContent=label; });
    grp.addEventListener('mousemove',(e)=>{ tooltip.style.left=(e.pageX+12)+'px'; tooltip.style.top=(e.pageY+12)+'px'; });
    grp.addEventListener('mouseleave',()=>{ tooltip.style.display='none'; });

    gHighlights.appendChild(grp);
  }

  function clampPan(){
    const vw=viewport.clientWidth,vh=viewport.clientHeight;
    const w=imgW*scale,h=imgH*scale;
    if(w<=vw)tx=(vw-w)/2;else{const minTx=vw-w,maxTx=0;tx=Math.min(maxTx,Math.max(minTx,tx));}
    if(h<=vh)ty=(vh-h)/2;else{const minTy=vh-h,maxTy=0;ty=Math.min(maxTy,Math.max(minTy,ty));}
  }
  function applyTransform(){clampPan();stage.style.transform=`translate(${tx}px,${ty}px) scale(${scale})`;}
  function fitToViewport(){
    if(!imgW||!imgH)return;
    const vw=viewport.clientWidth,vh=viewport.clientHeight;
    scale=Math.min(vw/imgW,vh/imgH);
    fitScale=scale; MIN_SCALE=fitScale;
    tx=(vw-imgW*scale)/2; ty=(vh-imgH*scale)/2;
    applyTransform();
  }
  function zoomAt(cx,cy,f){
    const old=scale; let next=Math.max(MIN_SCALE,Math.min(MAX_SCALE,scale*f));
    const k=next/old; const sx=(cx-tx), sy=(cy-ty); tx=cx-sx*k; ty=cy-sy*k; scale=next;
    renderRange(); applyTransform();
  }

  viewport.addEventListener('wheel',e=>{
    e.preventDefault(); const rect=viewport.getBoundingClientRect();
    zoomAt(e.clientX-rect.left,e.clientY-rect.top,(e.deltaY<0)?1.15:1/1.15);
  },{passive:false});
  let dragging=false,lx=0,ly=0;
  viewport.addEventListener('mousedown',e=>{dragging=true;lx=e.clientX;ly=e.clientY;});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging)return; tx+=(e.clientX-lx); ty+=(e.clientY-ly); lx=e.clientX; ly=e.clientY; applyTransform();
  });

  fitBtn.addEventListener('click',fitToViewport);
  startTimeSel.addEventListener('change',()=>{populatePlayerListForRange();renderRange();});
  endTimeSel.addEventListener('change',()=>{populatePlayerListForRange();renderRange();});
  killToggle.addEventListener('change',()=>{renderRange();});

  selectAllBtn.addEventListener('click',()=>{
    const paths=gatherPlayersInRange(); selectedPlayers=new Set(paths.keys());
    playerListDiv.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true);
    [...paths.keys()].forEach(n=>playerColors.set(n,'#ff0000'));
    renderRange();
  });
  clearAllBtn.addEventListener('click',()=>{
    selectedPlayers.clear();
    playerListDiv.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=false);
    renderRange();
  });

  fileInput.addEventListener('change',e=>{
    const f=e.target.files?.[0]; if(!f)return;
    const reader=new FileReader();
    reader.onload=()=>{parseADM(String(reader.result||'')); populateTimestamps(); populatePlayerListForRange(); fitToViewport(); renderRange();};
    reader.readAsText(f);
  });
  mapImg.addEventListener('load',()=>{
    imgW=mapImg.naturalWidth; imgH=mapImg.naturalHeight;
    overlay.setAttribute('viewBox',`0 0 ${imgW} ${imgH}`);
    overlay.setAttribute('width',imgW); overlay.setAttribute('height',imgH);
    stage.style.width=imgW+'px'; stage.style.height=imgH+'px';
    fitToViewport(); renderRange();
  });
})();
</script>
</body>
</html>
